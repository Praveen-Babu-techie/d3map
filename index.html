<!DOCTYPE html>
<style>
.states :hover {
  fill:  #67a9cf;
}
.states {
  fill: #CDDEEE;
/* fill:linear-gradient(red, yellow); */
  stroke: #fff;
}
.symbol{
    fill: #fff;
    stroke: #000;
    
		stroke-width: 1px;
}
body {
  overflow: hidden;
}

.state-borders {
  fill: none;
  stroke: #fff;
  stroke-width: 0.5px;
  stroke-linejoin: round;
  stroke-linecap: round;
  pointer-events: none;
}
#play-button {
  position: absolute;
  top: 120px;
  left: 30px;
  background: #004276;
  padding-right: 26px;
  border-radius: 2px;
  border: none;
  color: white;
  margin: 0;
  padding: 0 12px;
  width: 68px;
  cursor: pointer;
  height: 30px;
  font: 13px sans-serif;
}

#play-button:hover {
  background-color: #064d84;
}

#play-button:active {
  background-color: #002657;
}

.ticks {
  font: 10px sans-serif;
}

.track,
.track-inset,
.track-overlay {
  stroke-linecap: round;
}

.track {
  stroke: #000;
  stroke-opacity: 0.3;
  stroke-width: 10px;
}

.track-inset {
  stroke: #ddd;
  stroke-width: 8px;
}

.track-overlay {
  pointer-events: stroke;
  stroke-width: 50px;
  cursor: crosshair;
  visibility: hidden;
}

.handle {
  fill: #fff;
  stroke: #000;
  stroke-opacity: 0.5;
  stroke-width: 1.25px;
}
.slider{
  margin-top: 10%;
}
#svg {
    width:100%;
    height: auto;
}
</style>
<body>
 



<script src="//d3js.org/d3.v4.min.js"></script>
<!-- <button id="play-button" style="margin-top:400px">Pause</button> -->
<svg width="960" height="720" class="slider1" ></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/topojson.v2.min.js"></script>


    <svg width="960" height="600"></svg>
 <script>

//Width and height of map
var width = 960;
var height = 500;

var svg = d3.select("svg")
        // .append("div")
        .attr("id", "svg")
        .append("svg")
        .attr("viewBox", "0 0 " + width + " " + height )
        .attr("preserveAspectRatio", "xMinYMin");;

var projection = d3.geoAlbersUsa()
					.translate([width/2, height/2])    // translate to center of screen
				   	.scale([1000]);          // scale things down so see entire US

var path = d3.geoPath(projection);

// points
var	destination = [-73.7821139000000, 40.662688];
var origin = [-95.33678270000001, 29.9902199];
// var destination1 = [-96.86116286127009,32.86551504194938];
// var destination2 = [-115.68978,35.23926];
// var destination3=[-121.687309,41.497103];
var startYear = 1790
var currentYear = startYear;
var us = d3.json("US.json", function(error, us) {
  if (error) throw error;
  svg.append("g")
      .attr("class", "states")
    .selectAll("path")
    .data(topojson.feature(us, us.objects.states).features)
    .enter().append("path")
      .attr("d", path);
  svg.append("path")
      .attr("class", "state-borders")
      .attr("d", path(topojson.mesh(us, us.objects.states, function(a, b) { return a !== b; })));


 // add circles to svg


svg.selectAll("circle")
	.data([origin,destination]).enter()
	.append("circle")
  .attr("class","symbol")
	.attr("cx", function (d) { console.log(projection(d)); return projection(d)[0]; })
	.attr("cy", function (d) { return projection(d)[1]; })
	.attr("r", "5px")


	
var route = svg.append("path")
               .datum({type: "LineString", coordinates: [ origin,destination]})
               .attr("class", "route")
              //  .style("stroke-dasharray", totalLength + "," + totalLength)
               .attr("d", path)
               
               .attr("stroke", "#696969")
               
               .attr("fill", "none");

var totalLength = route.node().getTotalLength();





route
      .attr("stroke-dasharray", totalLength + "," + totalLength)
       .attr("stroke-dashoffset", totalLength)
       
      .transition()
      .duration(2000)
      // .ease(d3.easeCubic)
       .attr("stroke-dashoffset", totalLength*2)
       .style("stroke-dashoffset", totalLength + "," + totalLength)
     
 





// route = svg.append("path")
//                .datum({type: "LineString", coordinates: [destination1,destination]})
//                .attr("class", "route")
//                .attr("d", path)
//                .attr("stroke", "#696969")
//                .attr("fill", "none");

//  totalLength = route.node().getTotalLength();

// route
//       .attr("stroke-dasharray", totalLength + "," + totalLength)
//        .attr("stroke-dashoffset", totalLength)
//       .transition()
//       .delay(2000)
//       .duration(2000)
//       // .ease(d3.easeCubic)
//        .attr("stroke-dashoffset", totalLength*2)
//       // .transition()
//       // .duration(2000)
//       // .attr("stroke-dashoffset", totalLength*3);





// route = svg.append("path")
//                .datum({type: "LineString", coordinates: [destination2,destination1]})
//                .attr("class", "route")
//                .attr("d", path)
//                .attr("stroke", "#696969")
//                .attr("fill", "none");

//  totalLength = route.node().getTotalLength();

// route
//       .attr("stroke-dasharray", totalLength + "," + totalLength)
//        .attr("stroke-dashoffset", totalLength)
//       .transition()
//       .delay(4000)
//       .duration(2000)
//       // .ease(d3.easeCubic)
//        .attr("stroke-dashoffset", totalLength*2)
//       // .transition()
//       // .duration(2000)
//       // .attr("stroke-dashoffset", totalLength*3);



//       route = svg.append("path")
//                .datum({type: "LineString", coordinates: [destination3,destination2]})
//                .attr("class", "route")
//                .attr("d", path)
//                .attr("stroke", "#696969")
//                .attr("fill", "none");

//  totalLength = route.node().getTotalLength();

// route
//       .attr("stroke-dasharray", totalLength + "," + totalLength)
//        .attr("stroke-dashoffset", totalLength)
//       .transition()
//       .delay(6000)
//       .duration(2000)
//       // .ease(d3.easeCubic)
//        .attr("stroke-dashoffset", totalLength*2)
//       // .transition()
//       // .duration(2000)
//       // .attr("stroke-dashoffset", totalLength*3);

});

</script>
<!-- <script>






  let svg1 = d3.select("svg"),
      margin = { right: 50, left: 120},
      width1 = +svg1.attr("width") - margin.left - margin.right,
      height1 = +svg1.attr("height");
  
  let target = actual = 0,
      alpha = 0.2,
      timer = d3.timer(updateTween),
      stepTimer,
      moving = false,
      maxValue = 180 - 1,
      trailLength = 10;
  
  const playButton = d3.select("#play-button");

  const x = d3.scaleLinear()
      .domain([0, 24])
      .range([0, width1+5])
      .clamp(true);

  const slider = svg1.append("g")
    .attr("class", "slider")
    .attr("transform", "translate(" + margin.left + "," + height1 / 2 + ")")
    .attr("transform", "translate(120," + 525 + ")");


  slider.append("line")
    .attr("class", "track")
    .attr("x1", x.range()[0])
    .attr("x2", x.range()[1])
  .select(function() { return this.parentNode.appendChild(this.cloneNode(true)); })
    .attr("class", "track-inset")
  .select(function() { return this.parentNode.appendChild(this.cloneNode(true)); })
    .attr("class", "track-overlay")
    .call(d3.drag()
        .on("start.interrupt", () => slider.interrupt())
        .on("start drag", () => update(x.invert(d3.event.x))));


  slider.insert("g", ".track-overlay")
    .attr("class", "ticks")
    .attr("transform", "translate(0," + 19 + ")")
  .selectAll("text")
  .data(x.ticks(10))
  .enter().append("text")
    .attr("x", x)
    .attr("text-anchor", "middle")
    .text(d => d );



    const handle = slider.insert("circle", ".track-overlay")
    .attr("class", "handle")
    .attr("r", 9);

d3.select(window)
    .on("keydown", keydowned);

playButton
    .on("click", paused)
    .each(paused);


    function update(d) {
  target = d;
  moving = true;
  timer.restart(updateTween);
}

function updateTween() {
  let diff = target - actual;
  if (Math.abs(diff) < 1e-3) actual = target, timer.stop();
  else actual += diff * alpha;
 handle.attr("cx", x(actual));
  // svg.style("background-color", d3.hsl(actual, 0.8, 0.8));
}

function keydowned() {
  let currentValue = actual;
  if (d3.event.metaKey || d3.event.altKey) return;
  switch (d3.event.keyCode) {
    case 37: currentValue = Math.max(x.domain()[0], actual - trailLength); break;
    case 39: currentValue = Math.min(x.domain()[1], actual + trailLength); break;
    default: return;
  }
  update(currentValue);
  paused();
}






function paused() {
  
  if (moving) {
    slider.interrupt();
    // console.log(slider)
    
  
    clearInterval(stepTimer);
    moving = false;
    playButton.text("Play");
  } 
  
  
  else {
    if (actual > maxValue) actual = 0;
    stepTimer = setInterval(step, 100);
    moving = true;
    playButton.text("Pause");
  }
}

function step() {
  if (actual > maxValue) paused();
  else update(actual + trailLength / 25);
}












    </script> -->



</body>